c----------------------------------------------------------------------
      program trans
c
c     Stretch 2d data set to 3d       Paul F. Fischer  (pff@cfm.brown.edu)  9/6/95.
c     Updated to include circle sides                  (fischer@mcs.anl.gov) 3/29/99.
c
c
c     This code takes as input a 2D nekton file, blah.rea, and an optional
c     .fld file, blah.fld  (asci format -- param(67)=0 -- only). 
c
c     It generates a correpsonding translated 3D mesh of height Z-max, 
c     with an equi-partitioned number of levels in Z, given by nlev.
c     Both these are input by the user.
c
c     The code generates periodic-bc's in the Z-direction, all other bc's
c     are preserved.
c
c     A 3D .fld file is also generated.   However, n2to3 only supports ascii
c     formatted .fld files.   Thus, if you normally use binary .fld files you
c     must take a zero-step job with your 2D data to generate an ascii .fld
c     file.   This is done by setting output param(66)=0 in the .rea file,
c     param(67)=4 (or whatever you typically use...), nsteps=fintime=0, and
c     then specifying the .fld file of interest as a restart file near the
c     bottom of your 2D .rea file.    Run nekton ... the 0 step job will
c     dump out the initial conditions, in the format specified (p66=0, in 
c     this case).   Call the .fld file generated by this procedure blah.fld
c     if your .rea file is blah.rea.
c
c     Run n2to3.   Enter blah,  enter out, enter nlev and zmax.
c     
c     You now have out.rea and out.fld, both of which are 3D files.
c     Unfortunately, you don't have out.map and out.sep which are needed
c     in more recent versions of nekton.   To get these, you must run
c     out.rea through prenek.   Fire up prenek,  choose the name t.
c     Say that you wish to read previous parameters (out) and file (out)
c     Then just click "ACCEPT" at every step.  This will yield t.rea,
c     t.map, and t.sep, all needed to run nekton.
c
c     You're set to go.   Set up the run "t.rea" to take as a restart
c     condition "out.fld", and set p67=0, p66=4 near the top of the .rea
c     file.
c
c     Fire up nekton, and your 3D job should start right up with a translated
c     2D .fld file as an initial condition.
c      
c
      character*80 file
      character*1  file1(80)
      equivalence (file1,file)
      character*80 fout
      character*1  fout1(80)
      equivalence (fout1,fout)
c
      parameter(nelm=8888)
      common /array/ x(6,nelm),y(6,nelm),bc(5,6,nelm),curve(6,8,nelm)
      common /arrai/ nlev,nel,ncurve
      common /arrac/ cbc,ccurve,ca
      character*3 cbc(6,nelm)
      character*1 ccurve(8,nelm)
      character*1 ca(nelm)
      logical ifflow,ifheat
c
c
      call rzero(x,6*nelm)
c
c
c     for workstation:
      in = 5
c
c     for delta:
c     open(unit=7,file='indat',status='old',err=1999)
c     in = 7
c1999 continue
c
c     Get file name
      write(6,*) 'Input old (source) file name:'      
      call blank(file,80)
      read(in,80) file
      len = ltrunc(file,80)
   80 format(a80)
c
c     Get file name
      write(6,*) 'Input new (output) file name:'      
      call blank(fout,80)
      read(in,80) fout
      lou = ltrunc(fout,80)
c
      nlev = 1
      write(6,*) 'input number of levels: (1, 2, 3,... etc.?):'
      read(in,*) nlev
      write(6,*) 'input max z height:'
      read(in,*) zmax
c
c     stretch .rea data 
c
      call ccopy(file1(len+1),'.rea',4)
      call ccopy(fout1(lou+1),'.rea',4)
c
      open(unit=10, file=file)
      open(unit=11, file=fout)
      call rea23(zmax,neln)
c
      write(6,*)
      write(6,6) neln,(fout1(k),k=1,len+4)
    6 format(i4,' elements written to ',40a1)
c
      close (unit=10)
      close (unit=11)
c
c     Translate .fld data, if available
c
      call ccopy(file1(len+1),'.fld',4)
      call ccopy(fout1(lou+1),'.fld',4)
      open(unit=10, file=file,status='old',err=999)
      open(unit=11, file=fout)
c
      do idmp=1,100
         call fld23(nlev,neln)
      enddo
c
      write(6,*)
      write(6,6) neln,(fout1(k),k=1,len+4)
c
      close (unit=10)
      close (unit=11)
  999 continue
      stop
 9999 continue
      write(6,*) 'could not find file "indat". abort.'
      stop
      end
c-----------------------------------------------------------------------
      subroutine rea23(zmax,neln)
      character*80 string
      character*1  string1(80)
      equivalence (string1,string)
      character*4  string21
      equivalence (string21,string1(21))
      character*4  string30
      equivalence (string30,string1(30))
c
      character*1  a1
c
c     Nekton stuff
      parameter(nelm=8888)
      common /array/ x(6,nelm),y(6,nelm),bc(5,6,nelm),curve(6,8,nelm)
      common /arrai/ nlev,nel,ncurve
      common /arrac/ cbc,ccurve,ca
      character*3 cbc(6,nelm)
      character*1 ccurve(8,nelm)
      character*1 ca(nelm)
      logical ifflow,ifheat
c
c
      call rzero(x,6*nelm)
      call rzero(y,6*nelm)
      call rzero(bc,30*nelm)
      call blank(cbc,18*nelm)
c
c     Read parameters
c
      call readwrite(string,'NEKTON',6)
      read(10,80) string
      write(11,'(2x,a18)') ' 3 DIMENSIONAL RUN'
c
      call readwrite(string,'XFAC,YFAC',9)
      read(10,80) string
      write(11,10)
   10 format(1x,
     $'**MESH DATA** 6 lines are X,Y,Z;X,Y,Z. Columns corners 1-4;5-8')
c
c     Read mesh data
c
      read (10,*) nel,ndim
      ndim3 = 3
      if (nel.gt.nelm) then
         write(6,*) 'ABORT:  increase nelm in n2to3.f',nel,nelm
         call exit
      endif
      neln = nlev*nel
      write(11,11) neln,ndim3,neln
   11 format(3i6,11x,'NEL,NDIM,NELV')
c
c     Read & write xy data 
      dz = zmax/nlev
      z0 = 0.0
      z1 = dz
      do ie=1,nel      
         read (10,80) string
         ca(ie) = string1(32)
         len = ltrunc(string,80)
         read (10,*)   (x(k,ie),k=1,4)
         read (10,*)   (y(k,ie),k=1,4)
         write(11,81)  (string1(k),k=1,len)
         write(11,90)  (x(k,ie),k=1,4)
         write(11,90)  (y(k,ie),k=1,4)
         write(11,90)  (z0,k=1,4)
         write(11,90)  (x(k,ie),k=1,4)
         write(11,90)  (y(k,ie),k=1,4)
         write(11,90)  (z1,k=1,4)
      enddo
   90 format(4e14.6)
      len = ltrunc(string,80)
c
c     Translate data in z direction
      do ilev=2,nlev
         z0 = z1
         z1 = z1+dz
         do ie=1,nel      
c
            ien = ie + nel*(ilev-1)
            write(string21,'(i4)') ien
            write(string30,'(i2)') ilev
            string1(32) = ca(ie)
            string1(33) = ']'
c
            write(11,81)  (string1(k),k=1,len)
            write(11,90)  (x(k,ie),k=1,4)
            write(11,90)  (y(k,ie),k=1,4)
            write(11,90)  (z0,k=1,4)
            write(11,90)  (x(k,ie),k=1,4)
            write(11,90)  (y(k,ie),k=1,4)
            write(11,90)  (z1,k=1,4)
         enddo
      enddo
c
c     Curve sides added 3/26/99   pff
c
      call rdcurve
      call out_curve
      read (10,80) string
      len = ltrunc(string,80)
      write(11,81) (string1(k),k=1,len)
c
c     Fluid bc's
      ifflow = .true.
c
c     Thermal bc's
c
      ifheat = .false.
      write(6,*) 'Heat transfer? (y/n)'
      read (5,1) a1
    1 format(a1)
      if (a1.eq.'y' .or. a1.eq.'Y') ifheat = .true.
c
c
      if (.not.ifflow) then
         read (10,80) string
         len = ltrunc(string,80)
         write(11,81) (string1(k),k=1,len)
      endif
c
      nbc = 0
      if (ifflow) nbc=nbc+1
      if (ifheat) nbc=nbc+1
c
      do ibc=1,nbc
c
         read (10,80) string
         len = ltrunc(string,80)
         write(11,81) (string1(k),k=1,len)
c
         do ie = 1,nel
            if (nel.lt.1000) then
               do  k = 1,4
                  read (10,20) cbc(k,ie),id,jd,(bc(j,k,ie),j=1,5)
               enddo
            else
               do  k = 1,4
                  read (10,21) cbc(k,ie),id,jd,(bc(j,k,ie),j=1,5)
               enddo
            endif
c
c           Periodic bc's on Z plane
            bc(1,5,ie) = ie+(nlev-1)*nel
            bc(2,5,ie) = 6
            cbc(5,ie) = 'P  '
c
            bc(1,6,ie) = ie+nel
            bc(2,6,ie) = 5
            cbc(6,ie)  = 'E  '
            if (nlev.eq.1) then
               bc(1,6,ie) = ie
               cbc(6,ie)  = 'P  '
            endif
c
            do k=1,6
               if (neln.lt.1000) then
                  write(11,20) cbc(k,ie),ie,k,(bc(j,k,ie),j=1,5)
               else
                  write(11,21) cbc(k,ie),id,k,(bc(j,k,ie),j=1,5)
               endif
            enddo
            cbc(5,ie) = 'E  '
            bc (1,5,ie) = ie-nel
c
         enddo
c
         do ilev = 2,nlev
            do ie = 1,nel
               id = ie + nel*(ilev-1)
c              Periodic bc's on Z plane
               if (ilev.eq.nlev) then
                  cbc(6,ie) = 'P  '
                  bc(1,6,ie) = ie-nel
               endif
               do  k = 1,6
                  if (cbc(k,ie).eq.'P  ') bc(1,k,ie) = bc(1,k,ie)+nel
                  if (cbc(k,ie).eq.'E  ') bc(1,k,ie) = bc(1,k,ie)+nel
                  if (neln.lt.1000) then
                     write(11,20) cbc(k,ie),id,k,(bc(j,k,ie),j=1,5)
                  else
                     write(11,21) cbc(k,ie),id,k,(bc(j,k,ie),j=1,5)
                  endif
               enddo
            enddo
         enddo
c
      enddo
c
      call readwrite(string,'endendend',9)
c
   20 FORMAT(1x,A3,2I3,5G14.6)
   21 FORMAT(1x,A3,i5,i1,5G14.6)
c
   80 format(a80)
   81 format(80a1)
      return
      end
c-----------------------------------------------------------------------
      subroutine blank(s,n)
      character*1 s(1)
      do i=1,n
        s(i)=' '
      enddo
      return
      end
c-----------------------------------------------------------------------
      function ltrunc(s,n)
      character*1 s(1)
      ltrunc = 0
      do j=n,1,-1
         if (s(j).ne.' ') then
            ltrunc = j 
            return
         endif
      enddo
      return
      end
c-----------------------------------------------------------------------
      INTEGER FUNCTION INDX1(S1,S2,L2)
      CHARACTER*80 S1,S2
C
      N1=80-L2+1
      INDX1=0
      IF (N1.LT.1) RETURN
C
      DO 300 I=1,N1
         I2=I+L2-1
         IF (S1(I:I2).EQ.S2(1:L2)) THEN
            INDX1=I
            RETURN
         ENDIF
300   CONTINUE
C
      RETURN
      END
c-----------------------------------------------------------------------
      subroutine readwrite(sout,key,nk)
c
      character*80 sout,key
c
      character*80 string
      character*1  string1(80)
      equivalence (string1,string)
c
   80 format(a80)
   81 format(80a1)
c
      do i=1,90000      
         call blank(string,80)
         read (10,80,end=100,err=100) string
         len = ltrunc(string,80)
         write(11,81) (string1(k),k=1,len)
         if (indx1(string,key,nk).ne.0) return
      enddo
  100 continue
      return
      end
c-----------------------------------------------------------------------
      function glmax(a,n)
      real a(1)
      tmax=-99.0E20
      do 100 i=1,n
         tmax=max(tmax,a(i))
  100 continue
      glmax=tmax
      return
      end
c-----------------------------------------------------------------------
      function glmin(a,n)
      real a(1)
      tmin=99.0E20
      do 100 i=1,n
         tmin=min(tmin,a(i))
  100 continue
      glmin = tmin
      return
      end
c-----------------------------------------------------------------------
      subroutine addc(x,c,n)
      real x(1)
      do i=1,n
         x(i) = x(i)+c
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine cmult(x,c,n)
      real x(1)
      do i=1,n
         x(i) = x(i)*c
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine ccopy(x,y,n)
      character*1 x(1),y(1)
      do i=1,n
         x(i) = y(i)
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine rzero(x,n)
      real x(1)
      do i=1,n
         x(i) = 0.0
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine fld23(nlev,neln)
c
      character*80 string
      character*1  string1(80)
      equivalence (string1,string)
      character*16 s4
c
c     Nekton stuff
      parameter(nelm=8888)
      parameter(nxm=9)
      common /array/ data(6*nelm*nxm*nxm)
c
      integer nel,nx1,ny1
      save    nel,nx1,ny1
c
      if (nel.eq.0) then
         read(10,*,end=999,err=999) nel,nx1,ny1
         rewind(10)
      endif
c
      ndat = 0
      ndim = 2
      read(10,80,end=999,err=999) string
      if (indx1(string,' X ',3).ne.0) ndat = ndat + ndim
      if (indx1(string,' U ',3).ne.0) ndat = ndat + ndim
      if (indx1(string,' P ',3).ne.0) ndat = ndat + 1
      if (indx1(string,' T ',3).ne.0) ndat = ndat + 1
c
      write(s4,'(4i4)') neln,nx1,nx1,nx1
      call ccopy(string,s4,16)
      len = ltrunc(string,80)
      write(11,81) (string1(k),k=1,len)
c
c     Write CERROR header stuff...
c
c     read (10,'(6g11.4)') (data(ie),ie=1,nel)
      read (10,*) (data(ie),ie=1,nel)
      write(11,'(6g11.4)') (data(1),ie=1,neln)
c
      zero = 0.0
      k1 = 1
      k2 = ndat
      do ie=1,nel
         do kz=1,nx1
            j1 = k1
            j2 = k2
            do k=1,nx1*ny1
c              if (kz.eq.1) read (10,'(5g14.6)') (data(j),j=j1,j2)
               if (kz.eq.1) read (10,*) (data(j),j=j1,j2)
               write(11,'(1p5e14.6)') (data(j),j=j1,j1+1),zero,
     $                              (data(j),j=j1+2,j2)
               j1 = j2+1
               j2 = j2+ndat
            enddo
         enddo
         k1 = j1
         k2 = j2
      enddo
c
      do ilev = 2,nlev
         k1 = 1
         k2 = ndat
         do ie=1,nel
            do kz=1,nx1
               j1 = k1
               j2 = k2
               do k=1,nx1*ny1
                  write(11,'(1p5e14.6)') (data(j),j=j1,j1+1),zero,
     $                                 (data(j),j=j1+2,j2)
                  j1 = j2+1
                  j2 = j2+ndat
               enddo
            enddo
            k1 = j1
            k2 = j2
         enddo
      enddo
c
   80 format(a80)
   81 format(80a1)
  999 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine rdcurve
C
      parameter(nelm=8888)
      common /array/ x(6,nelm),y(6,nelm),bc(5,6,nelm),curve(6,8,nelm)
      common /arrai/ nlev,nel,ncurve
      common /arrac/ cbc,ccurve,ca
      character*3 cbc(6,nelm)
      character*1 ccurve(8,nelm)
      character*1 ca(nelm)
      CHARACTER*1 ANS
c
C     .Read formatted curve side data 
C
      READ(10,*)
      READ(10,*)NCURVE
      CALL RZERO(CURVE ,48*nelm)
      CALL BLANK(CCURVE, 8*nelm)
      IF (NCURVE.GT.0) THEN
         DO 50 ICURVE=1,NCURVE
            IF (nel.LT.1000) THEN
               READ(10,60,ERR=500,END=500) IEDG,IEG,R1,R2,R3,R4,R5,ANS
            ELSE
               READ(10,61,ERR=500,END=500) IEDG,IEG,R1,R2,R3,R4,R5,ANS
            ENDIF
            CURVE (1,IEDG,IEG)=R1
            CURVE (2,IEDG,IEG)=R2
            CURVE (3,IEDG,IEG)=R3
            CURVE (4,IEDG,IEG)=R4
            CURVE (5,IEDG,IEG)=R5
            CCURVE(  IEDG,IEG)=ANS
   50    CONTINUE
   60    FORMAT(I3,I3,5G14.6,1X,A1)
   61    FORMAT(I2,I6,5G14.6,1X,A1)
      ENDIF
      RETURN
C
C     Error handling:
C
  500 CONTINUE
      WRITE(6,501)
  501 FORMAT(2X,'ERROR READING CURVE SIDE DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDCURVE.')
      CALL EXIT
      RETURN
C
      END
c-----------------------------------------------------------------------
      subroutine out_curve
C
      parameter(nelm=8888)
      common /array/ x(6,nelm),y(6,nelm),bc(5,6,nelm),curve(6,8,nelm)
      common /arrai/ nlev,nel,ncurve
      common /arrac/ cbc,ccurve,ca
      character*3 cbc(6,nelm)
      character*1 ccurve(8,nelm)
      character*1 ca(nelm)
      CHARACTER*1 ANS
c
C     .Read formatted curve side data 
C
      neln = nlev*nel
      ncun = 2*nlev*ncurve
      write(11,11)
      write(11,12)NCUn
   11 format(' ***** CURVED SIDE DATA *****')
   12 format(i8
     $ ,' Curved sides follow IEDGE,IEL,CURVE(I),I=1,5, CCURVE')
      IF (NCURVE.GT.0) THEN
         DO 50 ilev=1,nlev
         DO 50 ieg=1,nel
         DO 50 iedg=1,8
            r1=CURVE (1,IEDG,IEG)
            r2=CURVE (2,IEDG,IEG)
            r3=CURVE (3,IEDG,IEG)
            r4=CURVE (4,IEDG,IEG)
            r5=CURVE (5,IEDG,IEG)
            ans=CCURVE( IEDG,IEG)
            ie =ieg + nel*(ilev-1)
            if (ans.eq.'C') then
               IF (neln.LT.1000) THEN
                  write(11,60) IEDG,IE,R1,R2,R3,R4,R5,ANS
                  ied4 = iedg+4
                  write(11,60) IED4,IE,R1,R2,R3,R4,R5,ANS
               ELSE
                  write(11,61) IEDG,IE,R1,R2,R3,R4,R5,ANS
                  ied4 = iedg+4
                  write(11,61) IED4,IE,R1,R2,R3,R4,R5,ANS
               ENDIF
            endif
   50    CONTINUE
   60    FORMAT(I3,I3,5G14.6,1X,A1)
   61    FORMAT(I2,I6,5G14.6,1X,A1)
      ENDIF
      RETURN
C
C     Error handling:
C
  500 CONTINUE
      WRITE(6,501)
  501 FORMAT(2X,'ERROR READING CURVE SIDE DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDCURVE.')
      CALL EXIT
      RETURN
      END
c-----------------------------------------------------------------------
